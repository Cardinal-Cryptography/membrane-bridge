#+TITLE: MOST relayer: High-Level Design Document
#+AUTHOR: F. Bielejec
#+EMAIL: fiip.bielejec@cardinals.cc
#+TEXINFO_PRINTED_TITLE: MOST relayer: High-Level Design Document
#+OPTIONS: ':t toc:t author:t email:t
#+LANGUAGE: en
#+STARTUP: overview

* DONE Introduction

This document describes the conceptual design of a relayer process, designed to listen to, sign and relay cross-chain transfer requests between Ethereum and AlephZero.

System architecture can be divided into components responsible for listening to and handling requests coming from the AlephZero chain and into Ethereum and the ones responsible for handling cross chain transfers in the opposite direction.

System is composed of various coupled components which comunicate with channels (akin to message passing, albeit much simpler).

Becasue of the vast differences in how these two chains operate and finalize blocks there are some differences in how these two sides operate.

* DONE Components handling AlephZero -> Ethereum transfer requests

#+BEGIN_SRC plantuml :file azero_eth_components.png
database "Cache" {
  [RedisManager] as redis
}

package "AlephZero events" {
  [Listener] as a0_listener
  [Handler 1] as a0_handler_1
  [...]
  [Handler n] as a0_handler_n
}

package "Message channels" {
  [Next block number] as a0_block_num
  [Block seal] as a0_block_seal
}

cloud {
  [Ethereum] as eth
  [AlephZero] as a0
}

a0_listener <.up. a0  : events subscription
a0_listener <.up. a0_block_num :  next block subscrption
a0_listener .up.> a0_block_seal : publish last processed block
redis .down.> a0_block_num : publish next block
redis <.up. a0_block_seal : last processed block subscription

a0_listener <.down.> a0_handler_1
a0_listener <.down.> a0_handler_n

a0_handler_1 .down.> eth : tx
a0_handler_n .down.> eth : tx
#+END_SRC
[[file:azero_eth_components.png][azero_eth_components.png]]

- *Listener*: maintains a subscription to the AlephZero chain. On boot it will receive the number of the next block to process and filter all the cross-chain transfer request events that occured between this cached number and the last finalized block. After that requests are handled concurrently in chunks of events from consecutive block ranges. Cache is updated as the concurrent event handlers spawned for each batch finish processing them, in the same order the batches arrived and were queued.
- *Handlers*: independent event handlers that are spawned for each request. After all the events from the batch of blocks acknowledge they have finished cache gets updated with the next block number.
Handlers sign and submit transactions to the MOST smart contract on the Ethereum chain, first by checking whether a given guardian signature is needed (maybe she already signed it, or maybe the request is already processed, or maybe some previous blocks were yanked). As long as it is needed in the last finalized block on ethereum, handler will sign it and wait for as long as the transaction appears in the last finalized block. Following pseudo-code is a conceptual representation of the exact logic followed by the handlers before acknowleding an cross-chain transfer request as handled:

#+BEGIN_SRC
do:
  if !request_needs_signing(@latest_block):
    sleep(60);
    continue;
  else
    sign_request()
while request_needs_signing(@finalized_block)
#+END_SRC

* DONE Components handling Ethereum -> AlephZero transfer requests

#+BEGIN_SRC plantuml :file eth_azero_components.png
database "Cache" {
  [RedisManager] as redis
}

package "Ethereum events" {
  [Listener] as eth_listener
  [Handler] as eth_handler
}

package "Message queues" {
  [Next block number] as eth_block_number
  [Events] as eth_events
}

cloud {
  [AlephZero] as a0
  [Ethereum] as eth
}

eth_listener <.. eth: events subscription
eth_listener .up.> eth_events : publish batch
eth_listener <..> eth_block_number: pub-sub
eth_handler <.up. eth_events : subsciption
eth_handler ..> a0 : tx
redis <.. eth_block_number: subscription
redis ..> eth_block_number: publish on boot
#+END_SRC
[[file:eth_azero_components.png][eth_azero_components.png]]

- *Listener*: maintains a subscription to the Ethereum chain. On boot it receives next block number after the last cached and proceeds to retrieve events in batches coming from consecutive blocks, between the last processed and the last finalized, whichever number is smaller. For each batch *Listener* publishes it on an Events channel for a *Handler* to pick up and process in a blokciing manner, i.e. the *Listener* doe snot process further until the current batch is entirely handed and the ecache is updated.
- *Handler*: a task which subscribes to the Events channels and acks whenever a given batch of transfer requests is succesfully handled. Each event in a batch is processed sequentially in a FIFO order.

* DONE Additional components
There are various ancillary components not part of the diagrams above:

- *Circuit Breaker*: Ciruit Breaker is a multiple-producer multiple-consumer channel, a message pushed to this channels by one of the components makes the remaining components drop all their tasks immediately, which returns control to the main thread. The relayer enters a shutdown/reboot loop, in which state the system tries to handle the next batch of requests, starting from the last succesfully processed block until the condition is removed.
- *Advisory Listener*: this is a process that listens to none, one or a collection of Advisory smart contracts, which are boolean flag contracts, deployed on the AlephZero chain, where interested parties can publish warnings that shut down the relayer operation. Notice that the smart contracts comprising the MOST do not observe these flags, only the relayer process does. If the Advisory Listener detects a flag it publishes to the circuit breaker channel.
- *Halted state Listener*: Twin processes that check whether the bridge on ther side has beeen halted by a governance ation. Detecting it means an event is published to the circuit breaker channel.
- *Signer*: a separate process reponsible for signing cross-chain request transaction payloads with a key stored within a hardware enclave.
